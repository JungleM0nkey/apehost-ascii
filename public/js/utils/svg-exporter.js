/**
 * SVG Exporter
 * Export ASCII art as scalable SVG graphics
 * Implements Issue #17 - SVG Export
 */

export class SVGExporter {
    constructor() {
        this.defaultOptions = {
            fontSize: 14,
            fontFamily: 'Courier New, Monaco, monospace',
            lineHeight: 1.2,
            backgroundColor: '#000000',
            textColor: '#00ff00',
            padding: 20,
            embedFont: false
        };
    }

    /**
     * Export ASCII art as SVG
     * @param {string} content - ASCII art content
     * @param {Object} options - Export options
     * @returns {string} SVG markup
     */
    export(content, options = {}) {
        const opts = { ...this.defaultOptions, ...options };
        const lines = content.split('\n');

        // Calculate dimensions
        const maxLineLength = Math.max(...lines.map(line => line.length));
        const textWidth = maxLineLength * (opts.fontSize * 0.6); // Approximate monospace width
        const textHeight = lines.length * (opts.fontSize * opts.lineHeight);
        const width = textWidth + (opts.padding * 2);
        const height = textHeight + (opts.padding * 2);

        // Build SVG
        let svg = this.createSVGHeader(width, height, opts);
        svg += this.createBackground(width, height, opts);

        if (opts.embedFont) {
            svg += this.embedFontDef(opts);
        }

        svg += this.createTextElements(lines, opts);
        svg += this.createSVGFooter();

        return svg;
    }

    /**
     * Create SVG header
     * @param {number} width - SVG width
     * @param {number} height - SVG height
     * @param {Object} options - Options
     * @returns {string} SVG header
     */
    createSVGHeader(width, height, options) {
        return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="${width}" height="${height}"
     viewBox="0 0 ${width} ${height}"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>ASCII Art Export</title>
  <desc>Generated by ApeHost ASCII Art Studio</desc>
  `;
    }

    /**
     * Create background rectangle
     * @param {number} width - Width
     * @param {number} height - Height
     * @param {Object} options - Options
     * @returns {string} Background SVG
     */
    createBackground(width, height, options) {
        return `  <rect width="${width}" height="${height}" fill="${options.backgroundColor}"/>
`;
    }

    /**
     * Create text elements for each line
     * @param {Array<string>} lines - Content lines
     * @param {Object} options - Options
     * @returns {string} Text elements SVG
     */
    createTextElements(lines, options) {
        const lineHeight = options.fontSize * options.lineHeight;
        let svg = `  <text font-family="${options.fontFamily}"
       font-size="${options.fontSize}px"
       fill="${options.textColor}"
       xml:space="preserve">\n`;

        lines.forEach((line, index) => {
            const y = options.padding + (index + 1) * lineHeight;
            // Escape special XML characters
            const escapedLine = this.escapeXML(line);
            svg += `    <tspan x="${options.padding}" y="${y}">${escapedLine}</tspan>\n`;
        });

        svg += `  </text>\n`;
        return svg;
    }

    /**
     * Embed font definition (optional)
     * @param {Object} options - Options
     * @returns {string} Font definition SVG
     */
    embedFontDef(options) {
        // For simplicity, we'll use web fonts or system fonts
        // In production, you could embed base64 font data
        return `  <defs>
    <style type="text/css">
      @import url('https://fonts.googleapis.com/css2?family=Courier+Prime&amp;display=swap');
    </style>
  </defs>
`;
    }

    /**
     * Create SVG footer
     * @returns {string} SVG footer
     */
    createSVGFooter() {
        return `</svg>`;
    }

    /**
     * Escape XML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped text
     */
    escapeXML(text) {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    }

    /**
     * Create download blob
     * @param {string} svg - SVG content
     * @param {string} filename - Filename
     */
    download(svg, filename = 'ascii-art.svg') {
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');

        link.href = url;
        link.download = filename;
        link.style.display = 'none';

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        setTimeout(() => URL.revokeObjectURL(url), 100);
    }

    /**
     * Export with theme colors
     * @param {string} content - ASCII content
     * @param {string} theme - Theme name
     * @returns {string} SVG markup
     */
    exportWithTheme(content, theme = 'matrix') {
        const themes = {
            matrix: {
                backgroundColor: '#000000',
                textColor: '#00ff00'
            },
            hacker: {
                backgroundColor: '#0d0d0d',
                textColor: '#00ff41'
            },
            retro: {
                backgroundColor: '#000080',
                textColor: '#ffaa00'
            },
            terminal: {
                backgroundColor: '#1e1e1e',
                textColor: '#ffffff'
            },
            amber: {
                backgroundColor: '#000000',
                textColor: '#ffb000'
            }
        };

        const themeColors = themes[theme] || themes.matrix;
        return this.export(content, themeColors);
    }

    /**
     * Convert SVG to PNG (using canvas)
     * @param {string} svgContent - SVG content
     * @param {number} scale - Scale factor for resolution
     * @returns {Promise<Blob>} PNG blob
     */
    async convertToPNG(svgContent, scale = 2) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            img.onload = () => {
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0);

                canvas.toBlob(blob => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        reject(new Error('Failed to convert to PNG'));
                    }
                }, 'image/png');
            };

            img.onerror = () => reject(new Error('Failed to load SVG'));

            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            img.src = URL.createObjectURL(blob);
        });
    }
}
